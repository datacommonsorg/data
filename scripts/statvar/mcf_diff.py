# Copyright 2022 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the 'License');
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#         https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an 'AS IS' BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
''' Utility functions to compare MCF nodes.
Normalizes MCF nodes and generates diffs.

To compare two MCF files through command line, run the following:
  python3 mcf_diff.py --mcf1=<MCF file> --mcf2=<MCF file>

Additional diffing commandline options:
  --ignore_property=<prop1>[,<prop2}...]
    Comma seperated list of properties to ignore when diffing MCF nodes.
  --ignore_nodes_with_pv=<prop1>:<value1}[,<prop2>:<value2>...]
    Ignore nodes containing any of the listed property:values.
    If the value is empty, nodes contaiing the property are ignored.
  --fingerprint_dcid
    Ignore the DCID and instead use fingerprint of all property-values in the node
    to locate and compare equivalent nodex.
    This is useful in comparing nodes from 'dc-import genmcf' output.
  --compare_dcids=<dcid1>[,<dcid2>...]
    Compare nodes with dcid listed in the comma seeprated list.
  --compare_nodes_with_pv:
    Only compare nodes with atleast one of the listed property:values.
    If the value is omitted, nodes containig the property with any value is considered.

Output options:
  --show_diff_nodes_only: Only display nodes with diffs.
     By default all nodes in input are displayed highlighting diffs, if any.

Examples:
Compare nodes with the property 'typeOf: dcs:Enumeration'
  python3 mcf_diff.py --mcf1=sample1.mcf --mcf2=sample2.mcf \
      --compare_nodes_with_pv=typeOf:Enumeration

Compare all nodes except those containing:  'typeOf: dcs:Place'
  python3 mcf_diff.py --mcf1=sample1.mcf --mcf2=sample2.mcf \
      --ignore_nodes_with_pv=typeOf:Place

Compare nodes across different runs of 'dc-import genmcf' to list
nodes missing or additional:
  python3 mcf_diff.py \
      --fingerprint_dcid \
      --mcf1=dc_generated/table_mcf_nodes_sample1.mcf \
      --mcf2=dc_generated/table_mcf_nodes_sample2.mcf
SVObs Nodes generated by dc-import have a local dcid.
The above compares nodes by property-values and calls out nodes deleted or added,
instead of a changed node.
'''

import difflib
import os
import pprint
import sys

from absl import app
from absl import flags
from absl import logging

_SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
sys.path.append(_SCRIPT_DIR)

from counters import Counters
from mcf_file_util import load_mcf_nodes, filter_mcf_nodes, normalize_mcf_node, normalize_value, node_dict_to_text, get_node_dcid, strip_namespace

_FLAGS = flags.FLAGS

flags.DEFINE_string('mcf1', '', 'MCF file with nodes')
flags.DEFINE_string('mcf2', '', 'MCF file with nodes')
flags.DEFINE_list(
    'ignore_property',
    [
        'description',
        'provenance',
        'memberOf',
        'name',
        'constraintProperties',
        'keyString',  # 'Node'
    ],
    'List of properties to be ignored in diffs.')
flags.DEFINE_bool(
    'fingerprint_dcid', False,
    'If set, ignores the dcid for nodes and instead uses fingerprint.')
flags.DEFINE_list(
    'ignore_nodes_with_pv', [],
    'Ignore nodes containing any of the property:values in the comma separated list.'
)
flags.DEFINE_list('compare_dcids', [],
                  'Compare nodes with dcids in the comma seperated list.')
flags.DEFINE_list(
    'compare_nodes_with_pv', [],
    'Compare nodes containing any of the property:values in the comma separated list.'
)
flags.DEFINE_bool('show_diff_nodes_only', True, 'Output nodes with diff only.')
flags.DEFINE_integer('log_level', logging.INFO,
                     'Log level messages to be shown.')


def add_counter(counters: dict, name: str, value: int = 1):
    '''Add a counter to the dict.'''
    counters[name] = counters.get(name, 0) + value


def print_counters(counters: dict):
    '''Print the counters.'''
    pp = pprint.PrettyPrinter(indent=4, stream=sys.stderr)
    pp.pprint(counters)


def get_diff_config() -> dict:
    '''Returns the config for MCF diff from flags.'''
    logging.set_verbosity(_FLAGS.log_level)
    return {
        'ignore_property': _FLAGS.ignore_property,
        'fingerprint_dcid': _FLAGS.fingerprint_dcid,
        'ignore_nodes_with_pv': _FLAGS.ignore_nodes_with_pv,
        'compare_dcids': _FLAGS.compare_dcids,
        'compare_nodes_with_pv': _FLAGS.ignore_nodes_with_pv,
        'show_diff_nodes_only': _FLAGS.show_diff_nodes_only,
    }


def diff_mcf_node_pvs(node1: dict,
                      node2: dict,
                      config: dict,
                      counters: dict = None) -> (bool, str):
    '''Compare PVs in two nodes and report differences in the counter.
    returns the lines with diff marked with '<' or '>' in the beginning.
    Returns a tuple of bool set to Trus if there is a diff and the diff string.'''
    if counters is None:
        counters = {}
    diff_lines = []
    dcid1 = get_node_dcid(node1)
    dcid2 = get_node_dcid(node2)

    # Remove any properties to be ignored.
    ignore_props = config.get('ignore_property', [])
    for p in ignore_props:
        if p in node1:
            node1.pop(p)
        if p in node2:
            node2.pop(p)

    # Normalize nodes and diff line by line.
    node1_str = node_dict_to_text(normalize_mcf_node(node1)).split('\n')
    node2_str = node_dict_to_text(normalize_mcf_node(node2)).split('\n')
    logging.debug(
        f'DEBUG: Comparing nodes:\n{node1_str}, \nNode2:{node2_str}\n')
    diff = difflib.ndiff(node1_str, node2_str)

    # Generate a diff string.
    diff_str = []
    has_diff = False
    for d in diff:
        diff_str.append(d)
        if d[0] == ' ':
            counters.add_counter(f'PVs matched', 1)
        elif d[0] == '-':
            has_diff = True
            counters.add_counter(f'missing pvs in mcf1', 1)
        elif d[0] == '+':
            has_diff = True
            counters.add_counter(f'missing pvs in mcf2', 1)
    if has_diff:
        if len(node1) > 0:
            if len(node2) > 0:
                counters.add_counter(f'nodes with diff', 1)
            else:
                counters.add_counter(f'nodes missing in mcf2', 1)
        else:
            counters.add_counter(f'nodes missing in mcf1', 1)
    else:
        counters.add_counter(f'nodes matched', 1)
    return has_diff, '\n'.join(diff_str)


def diff_mcf_nodes(nodes1: dict,
                   nodes2: dict,
                   config: dict = {},
                   counters: Counters = None) -> str:
    '''Compare nodes across two dicts and report differences as a dict of counters.'''
    if counters is None:
        counters = Counters()
    diff_str = []
    for dcid1 in nodes1.keys():
        if dcid1 not in nodes2:
            counters.add_counter(f'dcid missing in nodes2', 1,
                                 f'dcid={dcid1}, PVs={nodes1[dcid1]}')

    # Compare PVs across all nodes.
    all_dcids = set(list(nodes1.keys()))
    all_dcids.update(list(nodes2.keys()))
    for dcid in all_dcids:
        (has_diff, node_diff) = diff_mcf_node_pvs(nodes1.get(dcid, {}),
                                                  nodes2.get(dcid, {}), config,
                                                  counters)
        if not config.get('show_diff_nodes_only', False) or has_diff:
            diff_str.append(node_diff)
            diff_str.append('\n')

    dcids1 = set(nodes1.keys())
    dcids2 = set(nodes2.keys())
    diff = dcids2.difference(dcids1)
    for dcid2 in diff:
        counters.add_counter(f'dcid missing in nodes1', 1,
                             f'dcid={dcid2}, PVs={nodes2[dcid2]}')
    counters.print_counters()
    return ('\n'.join(diff_str))


def fingerprint_node(pvs: dict, ignore_props: set = {}) -> str:
    '''Returns a fingerprint of all PVs in the node.
    The fingerprint is a concatenated set of PVs sorted by the property.'''
    fp = []
    for p in sorted(pvs.keys()):
        if p not in ignore_props:
            fp.append(f'{p}:{pvs[p]}')
    return ';'.join(fp)


def fingerprint_mcf_nodes(nodes: dict, ignore_props: list = []) -> dict:
    '''Return a set of nodes with fingerprint as the key.'''
    fp_nodes = {}
    fp_ignore_props = set(['dcid', 'Node', 'value'])
    fp_ignore_props.update(ignore_props)
    for node, pvs in nodes.items():
        # Generate the fingerprint for the node with non-ignored PVs.
        fp_nodes[fingerprint_node(pvs, fp_ignore_props)] = nodes[node]
    return fp_nodes


def diff_mcf_files(file1: str,
                   file2: str,
                   config: dict = {},
                   counters: Counters = None) -> str:
    '''Compares MCF nodes in two files and returns the diffs.'''
    if counters is None:
        counters = Counters()
    nodes1 = filter_mcf_nodes(
        nodes=load_mcf_nodes(file1),
        allow_dcids=config.get('compare_dcids', None),
        allow_nodes_with_pv=config.get('allow_nodes_with_pv', None),
        ignore_nodes_with_pv=config.get('ignore_nodes_with_pv', None))
    counters.add_counter(f'input nodes in mcf1:{file1}', len(nodes1))
    nodes2 = filter_mcf_nodes(
        nodes=load_mcf_nodes(file2),
        allow_dcids=config.get('compare_dcids', None),
        allow_nodes_with_pv=config.get('allow_nodes_with_pv', None),
        ignore_nodes_with_pv=config.get('ignore_nodes_with_pv', None))
    counters.add_counter(f'input nodes in mcf2:{file2}', len(nodes2))
    if config.get('fingerprint_dcid', False):
        # Generate a fingerprint of all nodes instead of dcid.
        ignore_props = config.get('ignore_property', [])
        nodes1 = fingerprint_mcf_nodes(nodes1, ignore_props)
        nodes2 = fingerprint_mcf_nodes(nodes2, ignore_props)

    logging.info(
        f'Comparing {len(nodes1)} nodes from {file1} with {len(nodes2)} nodes from {file2}'
    )
    return diff_mcf_nodes(nodes1, nodes2, config, counters)


def main(_):
    if not _FLAGS.mcf1 or not _FLAGS.mcf2:
        print(
            f'Please provide two MCF files to compare with --mcf1=<file1> --mcf2=<file2>'
        )
    else:
        diff_mcf_files(_FLAGS.mcf1, _FLAGS.mcf2, get_diff_config())


if __name__ == '__main__':
    app.run(main)
