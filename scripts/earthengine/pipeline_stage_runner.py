# Copyright 2023 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the 'License');
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#         https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an 'AS IS' BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""Class for running a stage in the events pipeline.
To create a new stage in the events_pipeline, create a derived class of
StageRunner and overload run() with the stage speicifc processing.
Then register the stage runner with:
  register_stage_runner()
"""

import os
import sys

from absl import logging

_SCRIPTS_DIR = os.path.dirname(os.path.abspath(__file__))
sys.path.append(_SCRIPTS_DIR)
sys.path.append(os.path.dirname(_SCRIPTS_DIR))
sys.path.append(os.path.dirname(os.path.dirname(_SCRIPTS_DIR)))
sys.path.append(
    os.path.join(os.path.dirname(os.path.dirname(_SCRIPTS_DIR)), 'util'))

import file_util
import utils

from counters import Counters


class StageRunner:
    '''Class to run a single stage of the pipeline.
    Create a derived class with run() method calling necessary processing.
    Example:
      class MyStage(StageRunner):
        def __init__(self,
                     config_dicts: list = [],
                     state: dict = {},
                     counters=None):
          # Call StageRunner.set_up() to initialize settings.
          self.set_up('My-Stage', configs, state, counters)

        # Function called when the stage is run by the pipeline.
        # Return a list of output files generated by this stage.
        def run(self,
            input_files: list = None,
            config: dict = {},
            counters: Counters = None) -> list:
          outputs = []
          for file in input_files:
            outputs.append(my_process(file, config, counters))
          return outputs

    Then add the class to the map of stage names:_STAGE_RUNNERS below.
    '''

    def __init__(self,
                 config_dicts: list = [],
                 state: dict = {},
                 counters=None):
        self.set_up('runner', config_dicts, state, counters)

    def run(self,
            input_files: list = None,
            config: dict = {},
            counters: Counters = None) -> list:
        '''Override in child class.
       Returns the output files generated after running processing for this stage
       on the input_files.

       Args:
         input_files: List of files to process
           they are outputs from previous stage along with any files
           matching config['input_files'].
          config: dictionary of configuration settings for this stage.
          counters: global counters for the task.
       Returns:
         list of output files that are passed on to the next stage as inputs.
        '''
        logging.fatal(
            f'run() not implemented in {self.__class__}. Use a class with run() overridden.'
        )
        return []

    def set_up(self,
               name: str,
               config_dicts: list = [],
               state: dict = {},
               counters=None):
        '''Called by derived classes to set up configs and state in the base class.
        Args:
          name: string name of this stage, used in config
          config_dicts: dictionary of settings specific to this stage
          state: dictionary of parameters with current pipeline state
          counters: set of names counters for the pipeline
        '''
        self.name = name
        # Dynamic state with parameters to be updated after run.
        self.state = state
        # Set config as a merged dict
        self.config = _merge_dicts(config_dicts)
        self.config['stage_name'] = name
        # Counters for this stage.
        self.counters = counters
        if counters is None:
            self.counters = Counters()
        self.set_config_dates()
        self.set_output_dir()
        logging.info(
            f'Created stage: {name} with config: {self.config} from configs: {config_dicts}'
        )

    def get_name(self):
        '''Returns the name for this stage.'''
        return self.name

    def run_stage(self, input_files: list) -> list:
        '''Returns the output files after running the stage.
        Args:
          input_files: list of input files to be processed.
             It could be output from previous stages or files listed in the config.
        Returns:
          list of output files gnerated.
          This is passe don to the next stage as inputs.
        '''
        # Get input files from args or config.
        input_files = self.get_inputs(input_files)

        # Get resolved config for running stage.
        self.config.update(self.state)
        config = self.get_configs()

        # Run the stage
        logging.info(
            f'Running stage: {self.name} with {len(input_files)} inputs: {input_files} and config: {config}'
        )
        output_files = self.run(input_files, config, self.counters)
        logging.info(f'Got output for {self.name}: {output_files}')

        # Set the state for the stage
        stage_state = self.get_state(self.name, {})
        stage_state['input'] = ','.join(input_files)
        if output_files:
            if isinstance(output_files, list):
                stage_state['output'] = ','.join(output_files)
            else:
                stage_state['output'] = output_files
        self.set_state(self.name, stage_state)
        return output_files

    def get_inputs(self, inputs: list = []) -> list:
        '''Return a set of files matching inputs of the config.
        Gets files matching the pattern in the config for 'input_files'
        and the patter in the inputs list.
        '''
        # Get inputs from previous stage output and config.
        input_list = []
        if inputs:
            input_list.extend(inputs)
        config_inputs = self.get_config('input_files', '')
        if config_inputs:
            input_list.append(config_inputs)
        # Get list of existing files for the patterns.
        input_pat = _format(','.join(input_list), self.config)
        return file_util.file_get_matching(input_pat)

    def set_output_dir(self) -> str:
        '''Sets the output directory in the config if not set.'''
        if not self.get_config('output_dir', ''):
            import_dir = self.get_config('import_dir', '')
            output_dir = os.path.join(import_dir, self.name)
            self.set_config('output_dir', output_dir)

    def get_output_dir(self, config_dict: dict = {}) -> str:
        '''Returns the output directory from the config.'''
        return self.get_config('output_dir', '', config_dict)

    def get_output_filename(self,
                            input_filename: str = '',
                            config_dict: dict = {},
                            file_ext: str = '.csv') -> str:
        '''Returns the file name for output from the output_dir in the config
        and the basename of the input file with the file_ext specified.'''
        filename = self.get_config('output_file', '', config_dict)
        if not filename:
            # Create filename from GCS settings.
            output_dir = self.get_output_dir(config_dict)
            stage_name = self.get_name()
            if not output_dir:
                gcs_bucket = self.get_config('gcs_bucket', '')
                gcs_folder = self.get_config('gcs_folder', '')
                if gcs_bucket and gcs_folder:
                    output_dir = f'gs://{gcs_bucket}/{gcs_folder}/{stage_name}'
            if output_dir:
                if input_filename:
                    filename = file_util.file_get_name(os.path.join(
                        output_dir, os.path.basename(input_filename)),
                                                       suffix=f'-{stage_name}')
                else:
                    filename = f'{output_dir}/{import_name}-{stage_name}-{start_date}-{time_period}{file_ext}'

        return _format(filename, self.config)

    def should_skip_existing_output(self, filename: str) -> bool:
        '''Returns True if the output filename exists and
        skip_existing_output is True in the config.
        This is used to skip running a stage for outputs already generated.'''
        if self.get_config('skip_existing_output', True):
            existing_file = file_util.file_get_matching(filename)
            if existing_file:
                return True
        return False

    def get_config(self,
                   param: str,
                   default_value: str = '',
                   config_dict: dict = {}) -> str:
        '''Returns the resolved config value for the param from config_dict
        or object's config.'''
        if config_dict:
            value = config_dict.get(param, None)
            if value:
                return _format(value, config_dict)
        value = self.config.get(param, default_value)
        return _format(value, self.config)

    def set_config(self, param: str, value: str) -> str:
        '''Set the value of the config parameter.'''
        self.config[param] = value
        return value

    def get_configs(self) -> dict:
        '''Returns the dictionary of config parameter:values.'''
        return _get_resolved_dict(self.config)

    def get_state(self, key: str, default_value: str = '') -> str:
        '''Returns the value for the key from the processing state dict.'''
        return self.state.get(key, default_value)

    def set_state(self, key: str, value: str):
        '''Sets the value of the pipeline state.'''
        self.state[key] = value
        return value

    def set_config_dates(self, start_date: str = ''):
        '''Set the dates in the config based on processing state.
        if the config 'start_date' is set, then the configs for
        'year', 'month' and 'day' are also updated.

        Args:
          start_date: date string in the form YYYY-MM-DD for
            the start date for the stage.
        '''
        # Set start_date to be the next date from the last input date
        if start_date:
            self.set_config('start_date', start_date)
        start_date = self.get_config('start_date', '')
        if not start_date:
            # Set the start_date to the last processed date.
            last_input_date = self.get_state('last_input_date', '')
            if last_input_date:
                start_date = utils.date_advance_by_period(
                    self.get_state('last_input_date', ''),
                    self.get_config('time_period', 'P1M'))
                logging.info(
                    f'Setting start_date to {start_date} from last_input_date: {last_input_date}'
                )
            if not start_date:
                # No date set, set to start of year.
                start_date = utils.date_today('%Y-01-01')
                logging.info(
                    f'Setting start_date to start of year: {start_date}')
            if start_date:
                self.set_config('start_date', start_date)
        date_tokens = start_date.split('-')
        if len(date_tokens) > 0:
            self.set_config('year', date_tokens[0])
        if len(date_tokens) > 1:
            self.set_config('month', date_tokens[1])
        if len(date_tokens) > 2:
            self.set_config('day', date_tokens[2])


# List of runners for each names stage.
# Add any new classes derived from StageRunner here
# using register)_stage_runner()
_STAGE_RUNNERS = {}


def register_stage_runner(name: str, runner: StageRunner):
    '''Register the name for a stage runner class.
  Args:
    name: string used as name for the stage in pipeline configs.
    runner: class derived form StageRunner.
  '''
    global _STAGE_RUNNERS
    if name and name not in _STAGE_RUNNERS:
        _STAGE_RUNNERS[name] = runner
    else:
        logging.fatal(
            f'Invalid or existing name {name} for stage runner {runner}')


def get_stage_runner(name: str) -> StageRunner:
    '''Returns the stage runner class for the named stage.
    Args:
      name: string name of the runner.
        It should be registered with register_stage_runner() earlier.

    Throws a fatal exception if there is no runner registered for the name.
    '''
    if name in _STAGE_RUNNERS:
        return _STAGE_RUNNERS[name]
    logging.fatal(f'No stage runner registered for {name}')


def _merge_dicts(config_dicts: list) -> dict:
    config = {}
    if not isinstance(config_dicts, list):
        config_dicts = [config_dicts]
    for d in config_dicts:
        config.update(d)
    return config


def _get_resolved_dict(config: dict) -> dict:
    '''Resolve format string references in the values of the config dict.'''
    resolved_config = {}
    for param in config.keys():
        value = config[param]
        if value and isinstance(value, str):
            # Resolve string value.
            resolved_config[param] = _format(value, config)
        else:
            resolved_config[param] = value
    return resolved_config


def _format(string: str, params: dict) -> str:
    '''Returns the string with format patterns replaced.'''
    formatted_str = string
    try:
        if isinstance(string, str):
            formatted_str = string.format(**params)
        elif isinstance(string, list):
            formatted_str = [_format(s, params) for s in string]
    except (KeyError, IndexError) as e:
        logging.error(f'Format error for {string} with {params}')
    return formatted_str
